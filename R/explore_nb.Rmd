---
title: "Exploratory Notebook"
output:
  html_document:
    df_print: paged
    code_folding: hide
---
<!--
This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
-->

# Hello!
```{r}
#install.packages("ggforce")
```

```{r}
library(data.table)
library(ggforce)
```
```{r}
get_full_data <- function() {
  # block that imports the data and casts it into useful types for R
  data <- fread('/home/adrian/SingleCP_DotsReversal/processed/all_valid_data.csv')
  
  # set variables with appropriate type
  data[, `:=`(
    subject=as.factor(subject),
    dirChoice=as.factor(dirChoice),
    cpChoice=factor(cpChoice),  # doesn't create level for NA values
    dirCorrect=as.integer(dirCorrect),
    cpCorrect=as.integer(cpCorrect),
    initDirection=as.factor(initDirection),
    endDirection=as.factor(endDirection),
    presenceCP=factor(presenceCP, ordered=TRUE),
    viewingDuration=as.integer(viewingDuration * 1000),
    CPresponseSide=factor(CPresponseSide),
    block=factor(block, levels=c('Quest', 'Block2', 'Block3', 'Block4', 'Block5', 'Block6', 'Block7',
                                 'Block8', 'Block9', 'Block10', 'Block11')),
    probCP=factor(probCP, ordered=TRUE)
  )]
  
  # render levels more human-friendly
  levels(data$dirChoice) <- c('left', 'right')
  levels(data$cpChoice) <- c('no-CP', 'CP')
  levels(data$initDirection) <- c('right', 'left')
  levels(data$endDirection) <- c('right', 'left')
  levels(data$presenceCP) <- c('no-CP', 'CP')
  levels(data$CPresponseSide) <- c('left', 'right')
  
  return(data)
}

```


```{r}
data <- get_full_data()
str(data)
```

```{r}
# Example of confusion matrix-like table for choice vs. true direction of motion
build_confusion_table <- function(subj, session, block_name, coh, vd) {
  confusion <- table(
    data[subject==subj &
           date==session &
           block==block_name & 
           coherence==coh & 
           viewingDuration == vd,
         .(dirChoice, initDirection)]
  )
  pc <- confusion
}

# build_counts_dt <- function(subj, , coh, vd) {
#   confusion <- table(
#     data[subject==subj &
#            date==session &
#            block==block_name & 
#            coherence==coh & 
#            viewingDuration == vd,
#          .(dirChoice, initDirection)]
#   )
#   pc <- confusion
# }

# confusion table of choice for given PCP
build_confusion_pcp <- function(subj, coh, vd, pcp) {
  confusion <- table(
    data[subject==subj &
           coherence==coh & 
           viewingDuration == vd &
           probCP == pcp,
         .(dirChoice, initDirection)]
  )
  pc <- confusion
}
```


```{r}
# builds data.frame of arcs corresponding to a confusion table
# note: prop.table might be useful: https://rdrr.io/r/base/prop.table.html
build_arcs <- function(confusion_table) {
  dt <- as.data.table(confusion_table)
  
  trueLeft <- dt[initDirection == "left", sum(N)]
  trueRight <- dt[initDirection == "right", sum(N)]
  choseLeft <- dt[dirChoice == "left", sum(N)]
  choseRight <- dt[dirChoice == "right", sum(N)]
  
  totTrials <- trueLeft + trueRight
  angle <- 2*pi/totTrials
  
  # build arc for true direction
  start <- c(0, trueRight*angle)
  end <- c(trueRight*angle, 2*pi)
  r <- c(.52, .52, 1, 1)
  side <- factor(c('right', 'left', 'right', 'left'))
  
  # build arc for chosen direction
  startRight <- -dt[dirChoice == "right" & initDirection == "left", N]*angle
  endRight <- startRight + choseRight*angle
  
  startLeft <- endRight
  endLeft <- 2*pi + startRight
  
  start <- c(start, startRight, startLeft)
  end <- c(end, endRight, endLeft)
  
  dimension <- side  # just to standardize the name
  arcs <- data.frame(start, end, r, dimension)
  
  return(arcs)
}
  
#   
# # confusion_dtable here needs to be more than a classical 2x2 table
# build_grouped_arcs <- function(confusion_dtable) {
# 
#   trueLeft <- dt[initDirection == "left", sum(N)]
#   trueRight <- dt[initDirection == "right", sum(N)]
#   choseLeft <- dt[dirChoice == "left", sum(N)]
#   choseRight <- dt[dirChoice == "right", sum(N)]
#   
#   totTrials <- trueLeft + trueRight
#   angle <- 2*pi/totTrials
#   
#   # build arc for true direction
#   start <- c(0, trueRight*angle)
#   end <- c(trueRight*angle, 2*pi)
#   r <- c(.52, .52, 1, 1)
#   side <- factor(c('right', 'left', 'right', 'left'))
#   
#   # build arc for chosen direction
#   startRight <- -dt[dirChoice == "right" & initDirection == "left", N]*angle
#   endRight <- startRight + choseRight*angle
#   
#   startLeft <- endRight
#   endLeft <- 2*pi + startRight
#   
#   start <- c(start, startRight, startLeft)
#   end <- c(end, endRight, endLeft)
#   
#   dimension <- side  # just to standardize the name
#   arcs <- data.frame(start, end, r, dimension)
#   
#   return(arcs)
# }
```

```{r}
# arc_data is data.table returned by build_arcs()
# the inner donut is the true direction of motion, the outer one is subject's choice
plot_donut <- function(arc_data) {
  g <- ggplot(arc_data) +
    geom_arc(aes(x0 = 0, y0 = 0, r = r, start = start, end = end,
                 color = dimension), size=25) + 
    coord_fixed(xlim=c(-1.2,1.2), ylim=c(-1.2,1.2)) +
    theme(axis.title.x=element_blank(),
          axis.text.x=element_blank(),
          axis.ticks.x=element_blank(),
          axis.ticks.y=element_blank(),
          axis.text.y=element_blank(),
          axis.title.y=element_blank(),
          legend.text=element_text(size=16),
          legend.title = element_text(size=16)) 
  return(g)
}

# plot_donut_grid <- function(arc_data) {
#   g <- ggplot(arc_data) +
#     geom_arc(aes(x0 = 0, y0 = 0, r = r, start = start, end = end,
#                  color = dimension), size=25) + 
#     coord_fixed(xlim=c(-1.2,1.2), ylim=c(-1.2,1.2)) +
#     theme(axis.title.x=element_blank(),
#           axis.text.x=element_blank(),
#           axis.ticks.x=element_blank(),
#           axis.ticks.y=element_blank(),
#           axis.text.y=element_blank(),
#           axis.title.y=element_blank(),
#           legend.text=element_text(size=16),
#           legend.title = element_text(size=16)) + 
#     facet_grid(subject ~ viewingDuration)
#   return(g)
# }
```

```{r}
# s <- "S1"
# ss <- c("2019_06_20_12_54", "2019_06_21_13_08", "2019_06_27_11_33")
# bn <- 'Block2'
# c <- 100
# v <- 400
# for (sss in ss) {
#   p <- plot_donut(build_arcs(build_confusion_table(s, sss, bn, c, v)))
#   plot(p)
# }
```


```{r}
# curious data points
# s <- "S5"
# probcp <- 0
# c <- 62
# v <- 100

# s <- "S1"
# probcp <- 0
# c <- 100
# v <- 100

subj <- c("S5", "S1", "S2", "S5", "S4", "S3", "S2")
num_cases <- length(subj)
probcp <- rep_len(0, num_cases)
coh <- c(62, 100, 22.0, 0,0,0,100)
vd <- c(100, 100, 100, 100, 200, 200, 200)

cases <- data.table(subj, coh, vd, probcp)



call_with_row_args <- function(dt) {
  s <- dt[, subj]
  p <- dt[, probcp]
  c <- dt[, coh]
  v <- dt[, vd]
  return(build_confusion_pcp(s, c, v, p))
}

for (cc in 1:num_cases) {
  case_to_plot <- as.vector(cases[cc,])
  conftable <- call_with_row_args(case_to_plot)
  print("-------------------- CASE --------------------")
  print(case_to_plot)
  print(addmargins(conftable, FUN = list(Total = sum), quiet = TRUE))
  p <- plot_donut(build_arcs(conftable))
  plot(p)  
}

```



```{r}
# Example of confusion matrix-like table for CP response vs. true presenceCP
build_confusion_cpd <- function(subj, prob_cp, coh) {
  confusion <- table(
    data[subject==subj &
           probCP==as.character(prob_cp) &
           coherence==coh,
         .(cpChoice, presenceCP)]
  )
  pc <- confusion
  print(pc)
}

# builds data.frame of arcs corresponding to a confusion table
build_arcs_cpd <- function(confusion_table) {
  dt <- as.data.table(confusion_table)
  
  trueCP <- dt[presenceCP == "CP", sum(N)]
  trueNoCP <- dt[presenceCP == "no-CP", sum(N)]
  choseCP <- dt[cpChoice == "CP", sum(N)]
  choseNoCP <- dt[cpChoice == "no-CP", sum(N)]
  
  totTrials <- trueCP + trueNoCP
  angle <- 2*pi/totTrials
  
  # build arc for true direction
  start <- c(0, trueCP*angle)
  end <- c(trueCP*angle, 2*pi)
  
  # build arc for reported CP 
  startCP <- -dt[cpChoice == "CP" & presenceCP == "no-CP", N]*angle
  endCP <- startCP + choseCP*angle
  
  startNoCP <- endCP
  endNoCP <- 2*pi + startCP
  
  start <- c(start, startCP, startNoCP)
  end <- c(end, endCP, endNoCP)
  
  r <- c(.52, .52, 1, 1)
  CP <- factor(c('CP', 'no-CP', 'CP', 'no-CP'))
  
  dimension <- CP  # to standardize the name
  arcs <- data.frame(start, end, r, dimension)
  
  return(arcs)
}
```

```{r}
subjects <- c("S1", "S2", "S3", "S4", "S5")
pcp <- 0.2
c <- 100
for (s in subjects) {
  p <- plot_donut(build_arcs_cpd(build_confusion_cpd(s, pcp, c)))
  plot(p)
}
```

